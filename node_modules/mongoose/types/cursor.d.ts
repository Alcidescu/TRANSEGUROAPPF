declare module 'mongoose' {

  import stream = require('stream');

  type CursorFlag = 'tailable' | 'oplogReplay' | 'noCursorTimeout' | 'awaitData' | 'partial';

  interface EachAsyncOptions {
    parallel?: number;
    batchSize?: number;
    continueOnError?: boolean;
<<<<<<< HEAD
    signal?: AbortSignal;
  }

  class Cursor<DocType = any, Options = never, NextResultType = DocType | null> extends stream.Readable {
    [Symbol.asyncIterator](): Cursor<IteratorResult<DocType>, Options, IteratorResult<DocType>>;

    [Symbol.asyncDispose](): Promise<void>;
=======
  }

  class Cursor<DocType = any, Options = never> extends stream.Readable {
    [Symbol.asyncIterator](): AsyncIterableIterator<DocType>;
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909

    /**
     * Adds a [cursor flag](https://mongodb.github.io/node-mongodb-native/4.9/classes/FindCursor.html#addCursorFlag).
     * Useful for setting the `noCursorTimeout` and `tailable` flags.
     */
    addCursorFlag(flag: CursorFlag, value: boolean): this;

    /**
     * Marks this cursor as closed. Will stop streaming and subsequent calls to
     * `next()` will error.
     */
<<<<<<< HEAD
    close(): Promise<void>;

    /**
     * Destroy this cursor, closing the underlying cursor. Will stop streaming
     * and subsequent calls to `next()` will error.
     */
    destroy(): this;

    /**
=======
    close(callback: CallbackWithoutResult): void;
    close(): Promise<void>;

    /**
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909
     * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will
     * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even
     * if the resultant data has already been retrieved by this cursor.
     */
    rewind(): this;

    /**
     * Execute `fn` for every document(s) in the cursor. If batchSize is provided
     * `fn` will be executed for each batch of documents. If `fn` returns a promise,
     * will wait for the promise to resolve before iterating on to the next one.
     * Returns a promise that resolves when done.
     */
<<<<<<< HEAD
    eachAsync(fn: (doc: DocType[], i: number) => any, options: EachAsyncOptions & { batchSize: number }): Promise<void>;
    eachAsync(fn: (doc: DocType, i: number) => any, options?: EachAsyncOptions): Promise<void>;
=======
    eachAsync(fn: (doc: DocType[], index: number) => any, options: EachAsyncOptions & { batchSize: number }, callback: CallbackWithoutResult): void;
    eachAsync(fn: (doc: DocType, index: number) => any, options: EachAsyncOptions, callback: CallbackWithoutResult): void;
    eachAsync(fn: (doc: DocType[], index: number) => any, options: EachAsyncOptions & { batchSize: number }): Promise<void>;
    eachAsync(fn: (doc: DocType, index: number) => any, options?: EachAsyncOptions): Promise<void>;
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909

    /**
     * Registers a transform function which subsequently maps documents retrieved
     * via the streams interface or `.next()`
     */
    map<ResultType>(fn: (res: DocType) => ResultType): Cursor<ResultType, Options>;

    /**
     * Get the next document from this cursor. Will return `null` when there are
     * no documents left.
     */
<<<<<<< HEAD
    next(): Promise<NextResultType>;
=======
    next(callback: Callback<DocType | null>): void;
    next(): Promise<DocType>;
>>>>>>> 36e6c1d122dc190a65359e5ccef36f21fa6dd909

    options: Options;
  }
}
